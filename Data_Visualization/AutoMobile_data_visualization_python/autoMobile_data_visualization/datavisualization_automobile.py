# -*- coding: utf-8 -*-
"""Datavisualization_autoMobile.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hdmu9B1Xi-xVVTCdRCi87Jsvhap6sMgx
"""

# Commented out IPython magic to ensure Python compatibility.
# for data processing session
import pandas as pd
#seaborn is also data visualization library built on top of the matplotlib
import seaborn as sns 
#for data visualization 
import matplotlib.pyplot as plt
sns.set(color_codes=True) 
#Mainly used for inline plotting
# %matplotlib inline

#Import the csv file
auto_df = pd.read_csv("Automobile.csv")

#First five rows from the dataset
auto_df.head()

auto_df.columns.to_list()

auto_df.isna().any()

"""**Plotting univariate distributions**

The most convenient way to take a quick look at a univariate distribution in seaborn is the distplot() function. By default, this will draw a histogram and fit a kernel density estimate (KDE).
"""

sns.distplot(auto_df['normalized_losses']) #works on numerical value

sns.distplot(auto_df['engine_size']) #works on numerical value

sns.distplot(auto_df['city_mpg']) #works on numerical value

"""**Histograms**

Histograms are likely familiar, and a hist function already exists in matplotlib. A histogram represents the distribution of data by forming bins along the range of the data and then drawing bars to show the number of observations that fall in each bin.


To illustrate this, let’s remove the density curve and add a rug plot, which draws a small vertical tick at each observation. You can make the rug plot itself with the rugplot() function, but it is also available in distplot():
"""

sns.distplot(auto_df['city_mpg'], kde=False, rug=True) #works on numerical value
#rug used for number of variance or observation inside the dataplot

sns.distplot(auto_df['normalized_losses'], kde=False, rug=True) #works on numerical value
#rug used for number of variance or observation inside the dataplot

"""**What is Jointplot in Python?**

jointplot() : Draw a plot of two variables with bivariate and univariate graphs. This function provides a convenient interface to the 'JointGrid' class, with several canned plot kinds. This is intended to be a fairly lightweight wrapper; if you need more flexibility, you should use :class:'JointGrid' directly.

**Plotting bivariate distributions**

It can also be useful to visualize a bivariate distribution of two variables. The easiest way to do this in seaborn is to just use the jointplot() function, which creates a multi-panel figure that shows both the bivariate (or joint) relationship between two variables along with the univariate (or marginal) distribution of each on separate axes.

**Scatterplots**

The most familiar way to visualize a bivariate distribution is a scatterplot, where each observation is shown with point at the x and y values. This is analgous to a rug plot on two dimensions. You can draw a scatterplot with the matplotlib plt.scatter function, and it is also the default kind of plot shown by the jointplot() function:
"""

#Using jointPlot we are analyzing two continuous variable
sns.jointplot(auto_df["engine_size"], auto_df["horsepower"])

#kind: {"scatter" || "reg" || "resid" || "kde" || "hex" }
#sns.jointplot(auto_df["engine_size"], auto_df["horsepower"], kind="hex")
#sns.jointplot(auto_df["engine_size"], auto_df["horsepower"], kind="resid")
#sns.jointplot(auto_df["engine_size"], auto_df["horsepower"], kind="reg")
sns.jointplot(auto_df["engine_size"], auto_df["horsepower"], kind="kde")
#Kind=hex means instaed of point observation are plotted in Hexa Decimal

"""**Visualizing pairwise relationships in a dataset**

To plot multiple pairwise bivariate distributions in a dataset, you can use the pairplot() function. This creates a matrix of axes and shows the relationship for each pair of columns in a DataFrame. by default, it also draws the univariate distribution of each variable on the diagonal Axes:
"""

sns.pairplot(auto_df[["normalized_losses","engine_size","horsepower"]])

"""**Plotting with categorical data. **

One categorical variable & other continuous variable with the help of stripplot.

"""

sns.stripplot(auto_df["fuel_type"], auto_df["horsepower"])

"""In a strip plot, the scatterplot points will usually overlap. 
This makes it difficult to see the full distribution of data. 
One easy solution is to adjust the positions (only along the categorical axis) using some random “jitter"
"""

sns.stripplot(auto_df["fuel_type"], auto_df["horsepower"], jitter=True)

"""A different approach would be to use the function **swarmplot()**, which positions each scatterplot point on the categorical axis with an algorithm that avoids overlapping points:"""

sns.swarmplot(auto_df["fuel_type"], auto_df["horsepower"])

"""**Boxplots**
The first is the familiar boxplot(). This kind of plot shows the three quartile values of the distribution along with extreme values. The “whiskers” extend to points that lie within 1.5 IQRs of the lower and upper quartile, and then observations that fall outside this range are displayed independently. Importantly, this means that each value in the boxplot corresponds to an actual observation in the data:
"""

sns.boxenplot(auto_df["number_of_doors"], auto_df["horsepower"])
#Categorical & continuous varaible plotting

#Hue will create a legend value of the datapoint distribution
sns.boxenplot(auto_df["number_of_doors"], auto_df["horsepower"], hue=auto_df["fuel_type"])

"""**Bar plots**

A familiar style of plot that accomplishes this goal is a bar plot. In seaborn, the barplot() function operates on a full dataset and shows an arbitrary estimate, using the mean by default. When there are multiple observations in each category, it also uses bootstrapping to compute a confidence interval around the estimate and plots that using error bars:

Bar plots include 0 in the quantitative axis range, and they are a good choice when 0 is a meaningful value for the quantitative variable, and you want to make comparisons against it.
"""

sns.barplot(auto_df["body_style"], auto_df["horsepower"])

sns.barplot(auto_df["body_style"], auto_df["horsepower"],hue=auto_df["engine_location"])

"""**countplot():**

A special case for the bar plot is when you want to show the number of observations in each category rather than computing a statistic for a second variable. This is similar to a histogram over a categorical, rather than quantitative, variable. In seaborn, it’s easy to do so with the countplot() function:
"""

sns.countplot(auto_df["body_style"])

sns.countplot(auto_df["body_style"],hue=auto_df["engine_location"])

"""**Point plots**

An alternative style for visualizing the same information is offered by the pointplot() function. This function also encodes the value of the estimate with height on the other axis, but rather than show a full bar it just plots the point estimate and confidence interval. Additionally, pointplot connects points from the same hue category. This makes it easy to see how the main relationship is changing as a function of a second variable, because your eyes are quite good at picking up on differences of slopes:
"""

sns.pointplot(auto_df["fuel_system"],auto_df["horsepower"])

sns.pointplot(auto_df["fuel_system"],auto_df["horsepower"], hue=auto_df["number_of_doors"])

sns.pointplot(auto_df["fuel_system"],auto_df["horsepower"], hue=auto_df["number_of_cylinders"])

"""**Drawing multi-panel categorical plots**

"""

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="swarm")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="point")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="bar")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", hue="number_of_doors", col="engine_location", data=auto_df, kind="count")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="box")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="violin")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

sns.factorplot(x="fuel_type", y="horsepower", hue="number_of_doors", col="engine_location", data=auto_df, kind="strip")
#various types of kind input :{swarm,point,bar, count,box,violin,strip}

"""**Function to draw linear regression models**
**lmplot()** 
is one of the most widely used function to quickly plot the Linear Relationship b/w 2 variables
"""

sns.lmplot(x="horsepower", y="peak_rpm", data=auto_df)

sns.lmplot(x="horsepower", y="peak_rpm", data=auto_df, hue="fuel_type")